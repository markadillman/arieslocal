<!DOCTYPE html>
<!-- saved from url=(0073)http://web.engr.oregonstate.edu/~yorka/cs-467/tools/week-4/week4test.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

		<title>Team Aries: Week 4 Drawing Tool</title>

		<style type="text/css">
			/* make form entries begin on a new line */
			label {display: block;}
			h1 {font-size: 125%;}
			input[type=number] {width: 35px;}
		</style>

		<script src="js/svg.js/dist/svg.min.js"></script>
		<script src="js/jquery-3.2.1.js"></script>

		<script type="text/javascript">
		
			var debugging = false;	// toggle the debug messages
			var verboseDebugging = false; // toggle verbose debugging messages
			var useRedBox = true;	// canvas is just a red box (for debugging)
			var useFakeSurroundings = true; // surroundings are colored boxes (for debugging)
			var masking = false;	// toggle the platform masking tools
			var canvasObj;			// hidden canvas for getting color info
			var context;			// the context of the hidden canvas
			var canvasWidth = 600;	// size of the canvas
			var canvasHeight = 350;
			var canvasEdge = 50;	// size of the area showing surrounding tiles
			var canvasBorder = 1;	// stroke width of the borders for the tiles
			var drawControls;		// the drawing-specific tools
			var platformControls;	// the platform-specific tools
			var displayDiv;			// the display divs
			var displayDivList = [];
			var displayDivCanvasList = [];
			var displayDivContextList = [];
			var displayDivDict = {0: "aboveLeftDiv",
								  1: "aboveDiv",
								  2: "aboveRightDiv",
								  3: "leftDiv",
								  4: "centerDiv",
								  5: "rightDiv",
								  6: "belowLeftDiv",
								  7: "belowDiv",
								  8: "belowRightDiv"};
			
			// helper function to get individual display divs
			// assumes init() has already populated displayDivList
			// uses helper function from http://stackoverflow.com/a/28191966
			function getKeyByVal(object, value) {
				return Object.keys(object).find(key => object[key] === value);
			}
			function getDiv(divName) {
				return displayDivList[getKeyByVal(displayDivDict, divName)];
			}
			
			// initalize the rest of the page
			function init() {
				// create the hidden canvas for getting color info
				canvasObj = document.createElement("canvas");
				canvasObj.id = "canvasObj";
				canvasObj.width = canvasWidth;
				canvasObj.height = canvasHeight;
				
				// grab the context of the hidden canvas
				context = canvasObj.getContext("2d");
				
				// for debugging, set the entire canvas to red
				if (useRedBox) {
					var redBox = context.createImageData(canvasWidth, canvasHeight);
					for (var i = 0; i < redBox.data.length; i += 4) {
						redBox.data[i+0] = 255;
						redBox.data[i+1] = 0;
						redBox.data[i+2] = 0;
						redBox.data[i+3] = 255;
					}
					context.putImageData(redBox, 0, 0);
				}
				
				// grab the different groups of tools
				drawControls = document.getElementById("drawControls");
				platformControls = document.getElementById("platformControls");
				
				// set the default visibility of the tool groups
				drawControls.style.display = "block";
				platformControls.style.display = "none";
				
				// grab the display divs
				displayDiv = document.getElementById("displayDiv");
				for (var i in displayDivDict) {
					displayDivList[i] = document.getElementById(displayDivDict[i]);
				}
				
				// create the canvas objects for the non-center display divs
				var currentCanvas;
				var currentId;
				var currentWidth;
				var currentHeight;
				var currentContext;
				for (var i = 0; i < displayDivList.length; i += 1) {
					// don't try to do anything in the center div
					if (displayDivDict[i] != "centerDiv") {
						// create a canvas and set its id, width, and height
						currentId = displayDivDict[i] + "Canvas";
						currentCanvas = document.createElement("canvas");
						currentCanvas.id = currentId;
						currentWidth = canvasEdge;
						currentHeight = canvasEdge;
						if (i == 1 || i == 7 ) { // ??? maybe use the dict here?
							currentWidth = canvasWidth;
						}
						if (i == 3 || i == 5) {
							currentHeight = canvasHeight;
						}
						currentCanvas.width = currentWidth;
						currentCanvas.height = currentHeight;
						// set the click action for this canvas
						currentCanvas.addEventListener("click", surroundingEyeDropper, false);
						// add this canvas to the document so it will render
						displayDivList[i].appendChild(currentCanvas);
						// add this canvas to the canvas list
						displayDivCanvasList[i] = document.getElementById(currentId);
						// add its context to the context list
						currentContext = currentCanvas.getContext("2d");
						displayDivContextList[i] = currentContext;
					}
				}
				
				// load the image data into the non-center display div canvases
				if (useFakeSurroundings) { // use a bunch of colored blocks
					var colorBlock;
					for (var i = 0; i < displayDivCanvasList.length; i += 1) {
						// don't try to do anything in the center div
						if (i != getKeyByVal(displayDivDict, "centerDiv")) {
							// create the color block in canvas i
							currentCanvas = displayDivCanvasList[i];
							currentContext = displayDivContextList[i];
							colorBlock = currentContext.createImageData(currentCanvas.width, currentCanvas.height);
							for (var j = 0; j < colorBlock.data.length; j += 4) {
								colorBlock.data[j+0] = 0;
								colorBlock.data[j+1] = 0;
								colorBlock.data[j+2] = i*17 + 100;
								colorBlock.data[j+3] = 255;
							}
							currentContext.putImageData(colorBlock, 0, 0);
						}
					}
				} else { // use real image data from the server
					// ???
				}
				
				// position the overall display div
				displayDiv.style.position = "fixed";
				displayDiv.style.top = "10%";
				displayDiv.style.left = "25%";
				
				// set the size of the overall display div
				// took this out - this is handled by the individual divs now
				/*var divWidth = canvasWidth + (2 * canvasBorder) + (2 * canvasEdge);
				var divHeight = canvasHeight + (2 * canvasBorder) + (2 * canvasEdge);
				displayDiv.style.width =  divWidth.toString() + "px";
				displayDiv.style.height = divHeight.toString() + "px";*/
				
				// position all the other display divs inside the overall div
				var topVal, leftVal;
				for (var i = 0; i < displayDivList.length; i += 1) {
					displayDivList[i].style.position = "absolute";
					displayDivList[i].style.border = canvasBorder + "px solid grey";
					switch (i) { // ??? is there a more mathy way to do this?
						// ??? maybe use the dict here?
						case 0: // above left
							topVal = 0;
							leftVal = 0;
							break;
						case 1: // above
							topVal = 0;
							leftVal = canvasEdge + canvasBorder;
							break;
						case 2: // above right
							topVal = 0;
							leftVal = canvasEdge + canvasWidth + 2*canvasBorder;
							break;
						case 3: // left
							topVal = canvasEdge + canvasBorder;
							leftVal = 0;
							break;
						case 4: // center
							topVal = canvasEdge + canvasBorder;
							leftVal = canvasEdge + canvasBorder;
							break;
						case 5: // right
							topVal = canvasEdge + canvasBorder;
							leftVal = canvasEdge + canvasWidth + 2*canvasBorder;
							break;
						case 6: // below left
							topVal = canvasEdge + canvasHeight + 2*canvasBorder;
							leftVal = 0;
							break;
						case 7: // below
							topVal = canvasEdge + canvasHeight + 2*canvasBorder;
							leftVal = canvasEdge + canvasBorder;
							break;
						case 8: // below right
							topVal = canvasEdge + canvasHeight + 2*canvasBorder;
							leftVal = canvasEdge + canvasWidth + 2*canvasBorder;
							break;
						default: // should never get here
							console.log("Something went horribly awry with positioning the display divs.");
					}					
					displayDivList[i].style.top = topVal.toString() + "px";
					displayDivList[i].style.left = leftVal.toString() + "px";
					// set div sizes
					currentWidth = canvasEdge;
					currentHeight = canvasEdge;
					if (i == 1 || i == 7 ) { // ??? maybe use the dict here?
						currentWidth = canvasWidth;
					}
					if (i == 3 || i == 5) {
						currentHeight = canvasHeight;
					}
					if (i == 4) {
						currentWidth = canvasWidth;
						currentHeight = canvasHeight;
					}
					displayDivList[i].style.width = currentWidth + "px";
					displayDivList[i].style.height = currentHeight + "px";
				}
				
				// make the overall display div visible
				displayDiv.style.display = "block";
			}
			
			// stop event propagation so form doesn't actually submit
			function onFormSubmit(form_element) {
				return false;
			}
		
			// update option selctions from the form
			function changeDebugging(newState) {
				debugging = newState;
				window.setDebugging(newState);
			}
			function changeMasking(newState) {
				masking = newState;
				window.setMasking(newState);
				// change controls to match newState
				if (masking) { // make only platform tools visible
					drawControls.style.display = "none";
					platformControls.style.display = "block";
				} else { // make only drawing tools visible
					drawControls.style.display = "block";
					platformControls.style.display = "none";
				}
			}
			function changeColor(newColor) {
				window.setColor(newColor);
			}
			function changeShapeFill(newState) {
				window.setShapeFill(newState);
			}
			function changeStrokeWidth(newWidth) {
				newWidth = parseInt(newWidth);
				if (!isNaN(newWidth)) {
					window.setStrokeWidth(newWidth);
				}
			}
			function changeTool(newTool) {
				newTool = parseInt(newTool);
				if (!isNaN(newTool)) {
					window.setTool(newTool);
				}
			}
			
			// undo button
			function undoButton() {
				console.log("Undid an action.");
				alert("Sorry, undo doesn't work yet.");
			}
			
			// redo button
			function redoButton () {
				console.log("Redid an action.");
				alert("Sorry, redo doesn't work yet.");
			}
			
			// update option selections from the SVG
			function setColorChoiceInHTML(color) {
				var colorPicker = document.getElementById("color");
				colorPicker.value = color;
				changeColor(color); // send back to SVG just in case
			}
			
			// get the current SVG data from the SVG
			function getSVGData() {
				return window.sendSVGData();
			}
			
			// load the current SVG into the canvas, overwriting the old data
			function updateCanvas() {

				var dataString = getSVGData();
				if (verboseDebugging) {
					console.log(dataString);
				}
				// put this data into the canvas
				// ???
			}
			
			// helper functions to convert rgb integers into a hex color string
			function intToHexString(int) {
				var hexString = int.toString(16);
				if (hexString.length < 2) {
					hexString = "0" + hexString;
				}
				return hexString;
			}
			function rgbToHexString(red, green, blue) {
				var redString = intToHexString(red);
				var greenString = intToHexString(green);
				var blueString = intToHexString(blue);
				var hexString = "#" + redString + greenString + blueString;
				return hexString;
			}
			
			// get the color of a pixel at the given coordinate in the given context
			function getColorAt(myContext, xCoord, yCoord) {
				var pixelData = myContext.getImageData(xCoord, yCoord, 1, 1);
				var red = pixelData.data[0];
				var green = pixelData.data[1];
				var blue = pixelData.data[2];
				var color = rgbToHexString(red, green, blue);
				if (debugging) {
					console.log("Eye dropper at (" + xCoord.toString() + ", " +
							yCoord.toString() + ") found color: " + color);
				}
				return color;
			}
			
			// get the color of a pixel at the given coordinate in the drawing
			// this is the function the SVG calls
			function getColorInDrawingAt(xCoord, yCoord) {
				return getColorAt(context, xCoord, yCoord);
			}
			
			// perform the eye dropper for the surrounding art
			function surroundingEyeDropper(evt) {
				// only do this if the eye dropper is the selected tool
				if (document.getElementById("eyeDropper").checked) {
					// figure out which canvas you're in and get its context
					var myCanvas = evt.target;
					var myContext = myCanvas.getContext("2d");
					// get click coordinates in this canvas
					var coords = myCanvas.getBoundingClientRect();
					var mouseX = evt.clientX - coords.left;
					var mouseY = evt.clientY - coords.top;
					// get the color at that pixel in that region
					var color = getColorAt(myContext, mouseX, mouseY);
					// set this as the color choice
					setColorChoiceInHTML(color);
				} // else do nothing
			}

			//MARK'S CODE BEGINS HERE MARK'S CODE BEGINS HERE

			function artToString(){
				//using jQuery nodes, art group is index 5, platform 6
				return groupToString(5);
			}

			function platformToString(){
				//using jQuery nodes, art group is index 5, platform 6
				return groupToString(6);
			}

			function groupToString(groupnum){
				//select svg grouping
				var initsvg = document.getElementById("svgCanvas");
				//using jQuery nodes, art group is index 5, platform 6
				var tarGroup = initsvg.childNodes[groupnum];
				//use xml serializer to convert inaccessible InnerHTML to String
				var serializer = new XMLSerializer();
				var groupstring = serializer.serializeToString(tarGroup);
				//return the string
				if (debugging){
					console.log(groupstring);
				}
				return groupstring;
			}

			function onFormSubmit() {
				//get XML of both groups
				artGroupXML = artToString();
				platGroupXML = platformToString();
				//ENTER CODE FOR DETERMING THE CELL. THIS WILL EVENTUALLY BE STORED DATA
				//package them as strings and send them as payload of PUT
				var request = new XMLHttpRequest();
				var url = "http://ec2-52-42-5-103.us-west-2.compute.amazonaws.com/art";
				var payload = artGroupXML;
				request.open("POST",url,true);
				request.setRequestHeader("Content-type","application/xhtml+xml");
				request.send(data);
				return false;
			}

			/*
			Mark's code end.
			*/

		</script>

	</head>

	<body onload="init()">

		<h1>Team Aries: Week 4 Drawing Tool</h1>

		<form id="controls" onsubmit="return onFormSubmit(this)">
		
			<fieldset style="width: 20%">
			
				<legend><b>Drawing Tool Controls</b></legend>
				
				<div id="commonControls">
				
					<label>
						SEE DEBUG MESSAGES: 
						<input type="checkbox" name="debugging" value="debugging" onchange="changeDebugging(this.checked)"> 
					</label>
					
					<label>
						TOGGLE PLATFORM TOOLS: 
						<input type="checkbox" name="masking" value="masking" onchange="changeMasking(this.checked)"> 
					</label>
					
					<input type="button" name="undo" value="UNDO" onclick="undoButton()">
					
					<input type="button" name="redo" value="REDO" onclick="redoButton()">
						
					<input type="button" name="clear" value="CLEAR ALL" onclick="location.reload(true)">
				<label>
					SUBMIT EDITS:
					<input type="button" name="submit_button" onclick="onFormSubmit()"/>
				</label>
					<label>
						SELECT STROKE WIDTH: 
						<input type="number" name="strokewidth" value="1" min="1" max="50" onchange="changeStrokeWidth(this.value)"> 
					</label>
					
				</div>
				
				<div id="drawControls" style="display: block">
				
					<label>
						SELECT COLOR: 
						<input type="color" name="color" id="color" value="#000000" onchange="changeColor(this.value)"> 
					</label>
					
					<label>
						TOGGLE SHAPE FILL: 
						<input type="checkbox" name="shapefill" value="shapefill" onchange="changeShapeFill(this.checked)"> 
					</label>
					
					<label>
						SELECT TOOL TYPE:
						<br>
						<input type="radio" name="tool" value="0" checked="" onclick="changeTool(this.value)"> Rectangle
						<br>
						<input type="radio" name="tool" value="1" onclick="changeTool(this.value)"> Ellipse
						<br>
						<input type="radio" name="tool" value="2" onclick="changeTool(this.value)"> Polygon
						<br>
						<input type="radio" name="tool" value="3" onclick="changeTool(this.value)"> Brush
						<br>
						<input type="radio" name="tool" value="4" onclick="changeTool(this.value)"> Eraser
						<br>
						<input type="radio" name="tool" value="5" id="eyeDropper" onclick="changeTool(this.value)"> Eye Dropper
						<br>
						<input type="radio" name="tool" value="6" onclick="changeTool(this.value)"> Paint Can
					</label>
					
				</div>
				
				<div id="platformControls" style="display: none">
				
					<label>
						SELECT PLATFORM TYPE:
						<br>
						<input type="radio" name="platform" value="7" checked="" onclick="changeTool(this.value)"> Wall (solid)
						<br>
						<input type="radio" name="platform" value="8" onclick="changeTool(this.value)"> Ladder (permeable)
					</label>
				
				</div>
				
			</fieldset>

		</form>
			
		<br>
		
		<div id="displayDiv" style="display: block; position: fixed; top: 10%; left: 25%;">
			<div id="aboveLeftDiv" style="position: absolute; border: 1px solid grey; top: 0px; left: 0px; width: 50px; height: 50px;"><canvas id="aboveLeftDivCanvas" width="50" height="50"></canvas></div>
			<div id="aboveDiv" style="position: absolute; border: 1px solid grey; top: 0px; left: 51px; width: 600px; height: 50px;"><canvas id="aboveDivCanvas" width="600" height="50"></canvas></div>
			<div id="aboveRightDiv" style="position: absolute; border: 1px solid grey; top: 0px; left: 652px; width: 50px; height: 50px;"><canvas id="aboveRightDivCanvas" width="50" height="50"></canvas></div>
			<div id="leftDiv" style="position: absolute; border: 1px solid grey; top: 51px; left: 0px; width: 50px; height: 350px;"><canvas id="leftDivCanvas" width="50" height="350"></canvas></div>
			<div id="centerDiv" style="position: absolute; border: 1px solid grey; top: 51px; left: 51px; width: 600px; height: 350px;">
				<svg 	xmlns="http://www.w3.org/2000/svg"
				xmlns:xlink="http://www.w3.org/1999/xlink" id="svgCanvas" width="600" height="350" viewBox="0 0 600 350"
				onload="init(evt)">
					<script type="text/ecmascript"> <![CDATA[
						var debugging = false;			// toggle the debug messages
						var masking = false;			// toggle the platform masking tools
						var canvas;						// the SVG drawing region
						var drawingGroup;				// the group of SVG art objects
						var platformsGroup;				// the group of SVG platform objects
						var canvasWidth = 600;
						var canvasHeight = 350;
						var svgns;						// the namespace for SVG
						var xOffset = 0;				// offsets of the canvas in the page
						var yOffset = 0;
						var xStart = 0;					// start coords of current shape
						var yStart = 0;
						var colorChoice = "#000000";	// currently selected color
						var wallColor = "black";		// colors for platforms
						var ladderColor = "red";
						var toolList = ["Rectangle", "Ellipse", "Polygon", "Brush", "Eraser",
										"Eye Dropper", "Paint Can", "Wall", "Ladder"];
						var toolChoice = 0;				// currently selected tool
						var previousDrawTool = 0;		// saved tool choice for mode switching
						var previousPlatformTool = 7;	// saved tool choice for mode switching
						var strokeWidthChoice = 1;		// currently selected stroke width
						var shapeFillChoice = false;	// currently selected fill option
						var shapeFillNone = "none";
						var shapeFillChoiceString = shapeFillNone;
						var currentObject = 0;			// ID of current shape
						var currentPlatform = 0;		// ID of current platform shape
						var inProgress = false;			// shape currently in progress?
						var polygonCloseGap = 3;		// how close is final click of polygon?
						var polygonStartMarker = "polygonPointMarker";	// id string for polygon start marker
						var polygonPointMarker = "polygonStartMarker";	// id string for polygon point marker
						var polygonMarkerRadius = 3;		// size of the polygon point markers
	
						// initial setup
						function init(evt) {
							// select the empty svg object, get its namespace and offsets
							canvas = document.getElementById("svgCanvas");
							svgns = canvas.namespaceURI;
							var coords = canvas.getBoundingClientRect();
							xOffset = coords.left;
							yOffset = coords.top;
							
							// create the drawing canvas group
							drawingGroup = document.createElementNS(svgns, "g");
							drawingGroup.setAttribute("id", "drawingGroup");
							drawingGroup.setAttribute("style", "opacity: 1");
							canvas.appendChild(drawingGroup);
			
							// create the platforms canvas group
							platformsGroup = document.createElementNS(svgns, "g");
							platformsGroup.setAttribute("id", "platformsGroup");
							platformsGroup.setAttribute("style", "visibility: hidden");
							canvas.appendChild(platformsGroup);
		
							// set up event listeners for the canvas
							canvas.addEventListener("mousedown", mouseDown);
							canvas.addEventListener("mousemove", mouseMove);
							canvas.addEventListener("mouseup", mouseUp);
							canvas.addEventListener("click", mouseClick);
			
							// link HTML functions to SVG functions
							top.sendSVGData = svgSendSVGData;
							top.setDebugging = svgSetDebugging;
							top.setMasking = svgSetMasking;
							top.setColor = svgSetColor;
							top.setShapeFill = svgSetShapeFill;
							top.setStrokeWidth = svgSetStrokeWidth;
							top.setTool = svgSetTool;
						}
		
						// return the current svg data as a string
						function svgSendSVGData () {
							var dataString;
							//dataString = "test: sending SVG data as string";
							//dataString = (new XMLSerializer()).serializeToString(canvas);
							// use Mark's code to do this?
							return dataString;
						}
		
						// close out an in-progress shape first if an option selection changes
						function handleShapeInProgress() {
							// the only shape this could be is a polygon
							// so clean up a partly-completed polygon by leaving it a polyline
							// ??? this is copy-pasted and really should be refactored
							if (inProgress) {
								// get the current shape and its info, including the marker
								var newPolyline = document.getElementById(currentObject.toString());
								var pointString = newPolyline.getAttribute("points");
								var startMarker = document.getElementById(polygonStartMarker);
								var pointMarker = document.getElementById(polygonPointMarker);
								
								// remove the polygon point markers from the DOM
								drawingGroup.removeChild(startMarker);
								drawingGroup.removeChild(pointMarker);

								// mark that the shape is complete
								if (debugging) {
									console.log(currentObject.toString() +
									": Made a polyline at points: " + pointString + ".");
								}
								currentObject += 1;
								inProgress = false;
							}
						}
		
						// get updated option selections from the HTML form
						function svgSetDebugging(newState) {
							handleShapeInProgress();
							debugging = newState;
						}
						function svgSetMasking(newState) {
							handleShapeInProgress();
							masking = newState;
							if (masking) { // turn on platforms
								// turn the art opacity down
								drawingGroup.setAttribute("style", "opacity: 0.33");
								// make the platforms visible
								platformsGroup.setAttribute("style", "visibility: visible");
								// save current tool choice and set platform tool
								previousDrawTool = toolChoice;
								svgSetTool(previousPlatformTool);
							} else { // turn off platforms
								// turn the art opacity up
								 drawingGroup.setAttribute("style", "opacity: 1");
								// make the platforms invisible
								platformsGroup.setAttribute("style", "visibility: hidden");
								// save current tool choice and set draw tool
								previousPlatformTool = toolChoice;
								svgSetTool(previousDrawTool);
							}
						}
						function svgSetColor(newColor) {
							handleShapeInProgress();
							colorChoice = newColor;
							if (debugging) {
								console.log("Color changed to " + colorChoice + ".");
							}
						}
						function svgSetShapeFill(newState) {
							handleShapeInProgress();
							shapeFillChoice = newState;
							if (debugging) {
								console.log("Shape fill set to " + shapeFillChoice + ".");
							}
						}
						function svgSetStrokeWidth(newWidth) {
							handleShapeInProgress();
							if (newWidth < 1) {
								newWidth = 1;
							}
							else if (newWidth > 50) {
								newWidth = 50;
							}
							strokeWidthChoice = newWidth;
							if (debugging) {
								console.log("Stroke width set to " + strokeWidthChoice.toString() + ".");
							}
						}
						function svgSetTool(newTool) {
							handleShapeInProgress();
							toolChoice = newTool;
							if (debugging) {
								console.log("Tool changed to " + toolList[toolChoice] + ".");
							}
						}
						
						// ??? refactor these event handlers to reduce copy-pasta code?
						
						// mouse down event handler
						function mouseDown(evt) {
							switch(toolChoice) {
								case 0: // rectangle
								
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
									
									// create the new rectangle shape and set its attributes
									var newRect;
									newRect = document.createElementNS(svgns, "rect");
									newRect.setAttribute("id", currentObject.toString());
									newRect.setAttribute("x", xStart.toString());
									newRect.setAttribute("y", yStart.toString());
									newRect.setAttribute("width", "0");
									newRect.setAttribute("height", "0");
									if (shapeFillChoice) {
										shapeFillChoiceString = colorChoice;
									} else {
										shapeFillChoiceString = shapeFillNone;
									}
									newRect.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: " + 
										colorChoice + "; stroke-width: " +
										strokeWidthChoice.toString());
									
									// append rectangle to canvas and turn on inProgress flag
									drawingGroup.appendChild(newRect);
									inProgress = true;
									break;
									
								case 1: // ellipse
								
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
									
									// create the new ellipse shape and set its attributes
									var newEllipse;
									newEllipse = document.createElementNS(svgns, "ellipse");
									newEllipse.setAttribute("id", currentObject.toString());
									newEllipse.setAttribute("cx", xStart.toString());
									newEllipse.setAttribute("cy", yStart.toString());
									newEllipse.setAttribute("rx", "0");
									newEllipse.setAttribute("ry", "0");
									if (shapeFillChoice) {
										shapeFillChoiceString = colorChoice;
									} else {
										shapeFillChoiceString = shapeFillNone;
									}
									newEllipse.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: " + 
										colorChoice + "; stroke-width: " +
										strokeWidthChoice.toString());
									
									// append ellipse to canvas and turn on inProgress flag
									drawingGroup.appendChild(newEllipse);
									inProgress = true;
									break;

								case 2: // polygon
									break;

								case 3: // brush
									
									// get mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;

									// create the new polyline shape and set its attributes
									var newPolyline = document.createElementNS(svgns, "polyline");
									newPolyline.setAttribute("id", currentObject.toString());
									newPolyline.setAttribute("points", xStart.toString() + " " +
												yStart.toString());
									shapeFillChoiceString = shapeFillNone; // no fill for brush
									newPolyline.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: " + 
										colorChoice + "; stroke-width: " +
										strokeWidthChoice.toString() + 
										"; stroke-linecap: round; stroke-linejoin: round");
										
									// append polyline to canvas and turn on inProgress flag
									drawingGroup.appendChild(newPolyline);
									inProgress = true;
									break;

								case 4: // eraser
								
									// get mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;

									// create the new polyline shape and set its attributes
									var newPolyline = document.createElementNS(svgns, "polyline");
									newPolyline.setAttribute("id", currentObject.toString());
									newPolyline.setAttribute("points", xStart.toString() + " " +
												yStart.toString());
									shapeFillChoiceString = shapeFillNone; // no fill for brush
									newPolyline.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: #ffffff; stroke-width: " +
										strokeWidthChoice.toString() +
										"; stroke-linecap: round; stroke-linejoin: round");
										
									// append polyline to canvas and turn on inProgress flag
									drawingGroup.appendChild(newPolyline);
									inProgress = true;
									break;

								case 5: // eye dropper
									break;

								case 6: // paint can
									break;

								case 7: // wall
									
									// get mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;

									// create the new polyline shape and set its attributes
									var newPolyline = document.createElementNS(svgns, "polyline");
									newPolyline.setAttribute("id", currentPlatform.toString());
									newPolyline.setAttribute("points", xStart.toString() + " " +
												yStart.toString());
									shapeFillChoiceString = shapeFillNone; // no fill for brush
									newPolyline.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: " + 
										wallColor + "; stroke-width: " +
										strokeWidthChoice.toString() + 
										"; stroke-linecap: round; stroke-linejoin: round");
										
									// append polyline to platforms and turn on inProgress flag
									platformsGroup.appendChild(newPolyline);
									inProgress = true;
									break;
									
								case 8: // ladder
									
									// get mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;

									// create the new polyline shape and set its attributes
									var newPolyline = document.createElementNS(svgns, "polyline");
									newPolyline.setAttribute("id", currentPlatform.toString());
									newPolyline.setAttribute("points", xStart.toString() + " " +
												yStart.toString());
									shapeFillChoiceString = shapeFillNone; // no fill for brush
									newPolyline.setAttribute("style", "fill: " +
										shapeFillChoiceString + "; stroke: " + 
										ladderColor + "; stroke-width: " +
										strokeWidthChoice.toString() + 
										"; stroke-linecap: round; stroke-linejoin: round");
										
									// append polyline to platforms and turn on inProgress flag
									platformsGroup.appendChild(newPolyline);
									inProgress = true;
									break;
									
								default: // should never get here
									console.log("Something went horribly awry with the tool picker.");
							}
						}
						
						// mouse move event handler
						function mouseMove(evt) {
							switch(toolChoice) {
								case 0: // rectangle
									
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current rectangle
										var newRect;
										newRect = document.getElementById(currentObject.toString());
										
										// calculate new rectangle info
										var xNew = Math.min(xMouse, xStart);
										var yNew = Math.min(yMouse, yStart);
										var wNew =  Math.abs(xMouse - xStart);
										var hNew =  Math.abs(yMouse - yStart);
										
										// set new rectangle info
										newRect.setAttribute("x", xNew.toString());
										newRect.setAttribute("y", yNew.toString());
										newRect.setAttribute("width", wNew.toString());
										newRect.setAttribute("height", hNew.toString());
									}
									break;
									
								case 1: // ellipse
									
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current circle
										var newEllipse;
										newEllipse = document.getElementById(currentObject.toString());
										
										// calculate new rectangle info
										var xNew = Math.min(xMouse, xStart);
										var yNew = Math.min(yMouse, yStart);
										var wNew =  Math.abs(xMouse - xStart);
										var hNew =  Math.abs(yMouse - yStart);
										
										// calculate new circle info
										var rxNew = wNew/2;
										var ryNew = hNew/2;
										var cxNew = xNew + rxNew;
										var cyNew = yNew + ryNew;
										
										// set new circle info
										newEllipse.setAttribute("cx", cxNew.toString());
										newEllipse.setAttribute("cy", cyNew.toString());
										newEllipse.setAttribute("rx", rxNew.toString());
										newEllipse.setAttribute("ry", ryNew.toString());
									}
									break;

								case 2: // polygon
									break;

								case 3: // brush
								
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current polyline and its info
										var newPolyline;
										newPolyline = document.getElementById(currentObject.toString());
										var pointString = newPolyline.getAttribute("points");
										
										// add current point to the polyline
										pointString += " " + xMouse.toString() + " " + yMouse.toString();
										newPolyline.setAttribute("points", pointString);
									}
									break;

								case 4: // eraser
									
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current polyline and its info
										var newPolyline;
										newPolyline = document.getElementById(currentObject.toString());
										var pointString = newPolyline.getAttribute("points");
										
										// add current point to the polyline
										pointString += " " + xMouse.toString() + " " + yMouse.toString();
										newPolyline.setAttribute("points", pointString);
									}
									break;

								case 5: // eye dropper
									break;

								case 6: // paint can
									break;

								case 7: // wall
								
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current polyline and its info
										var newPolyline;
										newPolyline = document.getElementById(currentPlatform.toString());
										var pointString = newPolyline.getAttribute("points");
										
										// add current point to the polyline
										pointString += " " + xMouse.toString() + " " + yMouse.toString();
										newPolyline.setAttribute("points", pointString);
									}
									break;
					
								case 8: // ladder
				
									// only do this if a shape is currently in progress
									if(inProgress) {
										// get the mouse coordinates in the canvas
										var xMouse = evt.clientX - xOffset;
										var yMouse = evt.clientY - yOffset;
										
										// get the current polyline and its info
										var newPolyline;
										newPolyline = document.getElementById(currentPlatform.toString());
										var pointString = newPolyline.getAttribute("points");
										
										// add current point to the polyline
										pointString += " " + xMouse.toString() + " " + yMouse.toString();
										newPolyline.setAttribute("points", pointString);
									}
									break;
									
								default: // should never get here
									console.log("Something went horribly awry with the tool picker.");
							}
						}
						
						// mouse up event handler
						function mouseUp(evt) {
							switch(toolChoice) {
								case 0: // rectangle

									// debug output for completed rectangle
									if (debugging) {
										var newRect = document.getElementById(currentObject.toString());
										console.log(currentObject.toString() + ": Made a rectangle at (" +
												newRect.getAttribute("x") +	", " +
												newRect.getAttribute("y") + ") with width: " +
												newRect.getAttribute("width") + " and height: " +
												newRect.getAttribute("height") + ".");
									}
									
									// increment shape counter and turn off inProgress flag
									currentObject += 1;
									inProgress = false;
									break;
								
								case 1: // ellipse

									// debug output for completed ellipse
									if (debugging) {
										var newCircle = document.getElementById(currentObject.toString());
										console.log(currentObject.toString() + ": Made an ellipse at (" +
												newCircle.getAttribute("cx") +	", " +
												newCircle.getAttribute("cy") + ") with x-radius: " +
												newCircle.getAttribute("rx") + " and y-radius: " +
												newCircle.getAttribute("ry") + ".");
									}
									
									// increment shape counter and turn off inProgress flag
									currentObject += 1;
									inProgress = false;
									break;

								case 2: // polygon
									break;

								case 3: // brush
								
									// debug output for completed brush stroke
									if (debugging) {
										console.log(currentObject.toString() + ": Made a brush stroke.");
									}
					
									// increment shape counter and turn off inProgress flag
									currentObject += 1;
									inProgress = false;
									break;

								case 4: // eraser
									
									// debug output for completed eraser stroke
									if (debugging) {
										console.log(currentObject.toString() + ": Made an eraser stroke.");
									}
									
									// increment shape counter and turn off inProgress flag
									currentObject += 1;
									inProgress = false;
									break;

								case 5: // eye dropper
									break;

								case 6: // paint can
									break;

								case 7: // wall
								
									// debug output for completed wall
									if (debugging) {
										console.log(currentPlatform.toString() + ": Made a wall.");
									}
									
									// increment shape counter and turn off inProgress flag
									currentPlatform += 1;
									inProgress = false;
									break;
									
								case 8: // ladder
								
									// debug output for completed ladder
									if (debugging) {
										console.log(currentPlatform.toString() + ": Made a ladder.");
									}
									
									// increment shape counter and turn off inProgress flag
									currentPlatform += 1;
									inProgress = false;
									break;
									
								default: // should never get here
									console.log("Something went horribly awry with the tool picker.");
							}
						}
						
						// mouse click event handler
						function mouseClick(evt) {
							switch(toolChoice) {
								case 0: // rectangle
									break;
								
								case 1: // ellipse
									break;

								case 2: // polygon
								
									// get mouse coordinates in the canvas
									var xMouse = evt.clientX - xOffset;
									var yMouse = evt.clientY - yOffset;

									if (!inProgress) { // start a new polyline
										// create a polyline starting at the current mouse point
										xStart = xMouse;
										yStart = yMouse;
										var newPolyline = document.createElementNS(svgns, "polyline");
										newPolyline.setAttribute("id", currentObject.toString());
										newPolyline.setAttribute("points", xStart.toString() + " " +
													yStart.toString());
										shapeFillChoiceString = shapeFillNone; // no fill until done
										newPolyline.setAttribute("style", "fill: " +
											shapeFillChoiceString + "; stroke: " + 
											colorChoice + "; stroke-width: " +
											strokeWidthChoice.toString());
										drawingGroup.appendChild(newPolyline);
						
										// create the polygon start point marker
										var startMarker = document.createElementNS(svgns, "ellipse");
										startMarker.setAttribute("id", polygonStartMarker);
										startMarker.setAttribute("cx", xStart);
										startMarker.setAttribute("cy", yStart);
										startMarker.setAttribute("rx", polygonMarkerRadius);
										startMarker.setAttribute("ry", polygonMarkerRadius);
										startMarker.setAttribute("style", "font-family: sans-serif; " +
											"font-size: 14pt; stroke: " + colorChoice + "; fill: " +
											colorChoice);
										drawingGroup.appendChild(startMarker);

										// create the polygon current point marker
										var pointMarker = document.createElementNS(svgns, "ellipse");
										pointMarker.setAttribute("id", polygonPointMarker);
										pointMarker.setAttribute("cx", xStart);
										pointMarker.setAttribute("cy", yStart);
										pointMarker.setAttribute("rx", polygonMarkerRadius);
										pointMarker.setAttribute("ry", polygonMarkerRadius);
										pointMarker.setAttribute("style", "font-family: sans-serif; " +
											"font-size: 14pt; stroke: " + colorChoice + "; fill: " +
											colorChoice);
										drawingGroup.appendChild(pointMarker);

										// mark that a shape is in progress
										inProgress = true;

									} else { // continue the polyline in progress
										// get the current shape and its info, including the marker
										var newPolyline = document.getElementById(currentObject.toString());
										var pointString = newPolyline.getAttribute("points");
										var startMarker = document.getElementById(polygonStartMarker);
										var pointMarker = document.getElementById(polygonPointMarker);
						
										// check for the polygon being done/closed
										if ((Math.abs(xStart - xMouse) <= polygonCloseGap) && (
											Math.abs(yStart - yMouse) <= polygonCloseGap)) {
											// remove the polyline from the DOM
											drawingGroup.removeChild(newPolyline);

											// remove the polygon point markers from the DOM
											drawingGroup.removeChild(startMarker);
											drawingGroup.removeChild(pointMarker);

											// create a closed polygon to replace the polyline
											var newPolygon = document.createElementNS(svgns, "polygon");
											newPolygon.setAttribute("id", currentObject.toString());
											newPolygon.setAttribute("points", pointString);
											if (shapeFillChoice) {
												shapeFillChoiceString = colorChoice;
											} else {
												shapeFillChoiceString = shapeFillNone;
											}
											newPolygon.setAttribute("style", "fill: " +
												shapeFillChoiceString +
												"; fill-rule: evenodd; stroke: " + 
												colorChoice + "; stroke-width: " +
												strokeWidthChoice.toString());
											drawingGroup.appendChild(newPolygon);

											// mark that the shape is complete
											if (debugging) {
												console.log(currentObject.toString() +
												": Made a polygon at points: "+
												newPolygon.getAttribute("points") + ".");
											}
											currentObject += 1;
											inProgress = false;
										} else { // just add the current mouse point to the current polyline
											pointString += " " + xMouse.toString() +
												" " + yMouse.toString();
											newPolyline.setAttribute("points", pointString);

											// update the polygon current point marker
											pointMarker.setAttribute("cx", xMouse);
											pointMarker.setAttribute("cy", yMouse);
										}
									}
									break;

								case 3: // brush
				
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
					
									// create a dot/ellipse and set its attributes
									var newDot;
									newDot = document.createElementNS(svgns, "ellipse");
									newDot.setAttribute("id", currentObject.toString());
									newDot.setAttribute("cx", xStart.toString());
									newDot.setAttribute("cy", yStart.toString());
									newDot.setAttribute("rx", strokeWidthChoice.toString()/2);
									newDot.setAttribute("ry", strokeWidthChoice.toString()/2);
									newDot.setAttribute("style", "fill: " +
										colorChoice + "; stroke: " + colorChoice);
									
									// debug output for completed brush stroke
									if (debugging) {
										console.log(currentObject.toString() + ": Made a brush stroke.");
									}
									
									// append dot to canvas and increment object counter
									drawingGroup.appendChild(newDot);
									currentObject += 1;
									break;

								case 4: // eraser
								
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
									
									// create a dot/ellipse and set its attributes
									var newDot;
									newDot = document.createElementNS(svgns, "ellipse");
									newDot.setAttribute("id", currentObject.toString());
									newDot.setAttribute("cx", xStart.toString());
									newDot.setAttribute("cy", yStart.toString());
									newDot.setAttribute("rx", strokeWidthChoice.toString()/2);
									newDot.setAttribute("ry", strokeWidthChoice.toString()/2);
									newDot.setAttribute("style", "fill: #ffffff; stroke: #ffffff");
					
									// debug output for completed eraser stroke
									if (debugging) {
										console.log(currentObject.toString() + ": Made an eraser stroke.");
									}
									
									// append dot to canvas and increment object counter
									drawingGroup.appendChild(newDot);
									currentObject += 1;
									break;

								case 5: // eye dropper
								
									// get mouse coordinates in the canvas
									var xMouse = evt.clientX - xOffset;
									var yMouse = evt.clientY - yOffset;

									// get the color at these coordinates
									top.updateCanvas();
									var currentColor = top.getColorInDrawingAt(xMouse, yMouse);
									
									// set this color here and in the HTML form's color picker
									colorChoice = currentColor;
									top.setColorChoiceInHTML(currentColor);
									break;

								case 6: // paint can
									break;

								case 7: // wall
				
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
					
									// create a dot/ellipse and set its attributes
									var newDot;
									newDot = document.createElementNS(svgns, "ellipse");
									newDot.setAttribute("id", currentPlatform.toString());
									newDot.setAttribute("cx", xStart.toString());
									newDot.setAttribute("cy", yStart.toString());
									newDot.setAttribute("rx", strokeWidthChoice.toString()/2);
									newDot.setAttribute("ry", strokeWidthChoice.toString()/2);
									newDot.setAttribute("style", "fill: " +
										wallColor + "; stroke: " + wallColor);
									
									// debug output for completed wall
									if (debugging) {
										console.log(currentPlatform.toString() + ": Made a wall.");
									}
									
									// append dot to canvas and increment object counter
									platformsGroup.appendChild(newDot);
									currentPlatform += 1;
									break;
									
								case 8: // ladder
								
									// get the mouse coordinates in the canvas
									xStart = evt.clientX - xOffset;
									yStart = evt.clientY - yOffset;
									
									// create a dot/ellipse and set its attributes
									var newDot;
									newDot = document.createElementNS(svgns, "ellipse");
									newDot.setAttribute("id", currentPlatform.toString());
									newDot.setAttribute("cx", xStart.toString());
									newDot.setAttribute("cy", yStart.toString());
									newDot.setAttribute("rx", strokeWidthChoice.toString()/2);
									newDot.setAttribute("ry", strokeWidthChoice.toString()/2);
									newDot.setAttribute("style", "fill: " +
										ladderColor + "; stroke: " + ladderColor);
									
									// debug output for completed ladder
									if (debugging) {
										console.log(currentPlatform.toString() + ": Made a ladder.");
									}
									
									// append dot to canvas and increment object counter
									platformsGroup.appendChild(newDot);
									currentPlatform += 1;
									break;

								default: // should never get here
									console.log("Something went horribly awry with the tool picker.");
							}
						}
					]]> </script>
				</svg>
			</div>
			<div id="rightDiv" style="position: absolute; border: 1px solid grey; top: 51px; left: 652px; width: 50px; height: 350px;"><canvas id="rightDivCanvas" width="50" height="350"></canvas></div>
			<div id="belowLeftDiv" style="position: absolute; border: 1px solid grey; top: 402px; left: 0px; width: 50px; height: 50px;"><canvas id="belowLeftDivCanvas" width="50" height="50"></canvas></div>
			<div id="belowDiv" style="position: absolute; border: 1px solid grey; top: 402px; left: 51px; width: 600px; height: 50px;"><canvas id="belowDivCanvas" width="600" height="50"></canvas></div>
			<div id="belowRightDiv" style="position: absolute; border: 1px solid grey; top: 402px; left: 652px; width: 50px; height: 50px;"><canvas id="belowRightDivCanvas" width="50" height="50"></canvas></div>
		</div>
	</body>
</html>